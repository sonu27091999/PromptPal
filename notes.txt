============================================= manifest.json =============================================
=> `manifest.json` file is the heart of every Chrome extension. It tells the browser what your extension does, how it behaves, and what files and permissions it needs.
    üß© manifest.json ‚Äì Purpose & Significance
        This file:
            ‚Üí Declares extension metadata (name, version, description)
            ‚Üí Defines entry points (popup UI, background scripts, content scripts, etc.)
            ‚Üí Grants permissions to access browser APIs or modify pages
            ‚Üí Sets up features like actions, service workers, and web-accessible resources
    
    üìù Sample Breakdown (Manifest V3)
        {
            "manifest_version": 3,
            "name": "PromptPal",
            "version": "1.0",
            "description": "AI Chat Assistant for the Browser",

            "action": {
                "default_popup": "index.html",
                "default_icon": "icon.png"
            },

            "background": {
                "service_worker": "background.js"
            },

            "permissions": ["storage", "activeTab", "scripting"],

            "host_permissions": ["<all_urls>"],

            "icons": {
                "16": "icon16.png",
                "48": "icon48.png",
                "128": "icon128.png"
            }
        }

    üìñ Key Fields Explained
        +--------------------+--------------------------------------------------------------------------+
        |       Field        |                                Purpose                                   |
        +--------------------+--------------------------------------------------------------------------+
        | manifest_version   | Must be `3` (latest version required by Chrome)                          |
        | name               | Extension‚Äôs name (as seen in Chrome Web Store or Extensions page)        |
        | version            | Semantic versioning (`1.0`, `1.1.2`, etc.)                               |
        | description        | Short explanation of what the extension does                             |
        | action             | Defines the popup (the React UI you'll load) and optional icons          |
        | default_popup      | Entry HTML file for the extension's popup UI (e.g., `index.html`)        |
        | background         | Points to a `service_worker` file that runs in the background            |
        | permissions        | Grants access to browser APIs (e.g., `storage`, `tabs`, etc.)            |
        | host_permissions   | Grants access to specific sites (or all with `<all_urls>`)               |
        | icons              | Used for branding in browser UI and extension store                      |
        +--------------------+--------------------------------------------------------------------------+


============================================= vite.config.js =============================================
=> `vite.config.js` file is a well-configured setup tailored for building a React-based Chrome extension using Manifest V3, and it's leveraging modern Vite tooling with CRX support.
    üìù Sample Breakdown
        import { defineConfig } from 'vite'
        import react from '@vitejs/plugin-react'
        import { crx } from '@crxjs/vite-plugin'
        import manifest from './manifest.json'
        import path from 'path'

        // https://vite.dev/config/
        export default defineConfig({
            plugins: [react(), crx({ manifest })],
            resolve: {
                alias: {
                '@': path.resolve(__dirname, './src'),
                },
            },
        })

    üß© What is crx?
        In the context of your vite.config.js, this refers to:

        import { crx } from '@crxjs/vite-plugin'
        So crx here is not the Chrome .crx file format per se ‚Äî it's a Vite plugin called:
        @crxjs/vite-plugin

    üì¶ What is @crxjs/vite-plugin?
        It's a powerful plugin that lets you build Chrome Extensions (Manifest V3) using Vite.

        ‚úÖ Why is it important?
            Chrome Extensions are not regular web apps. They have special components like:
                ‚Üí Content Scripts
                ‚Üí Background Service Workers
                ‚Üí Popup HTML
                ‚Üí Manifest files
                ‚Üí Permissions & isolated scopes
                ‚Üí This plugin handles all of that seamlessly inside a Vite-based project.
        
    ‚öôÔ∏è What does crx() do under the hood?
        When you use:
            crx({ manifest })

        It:
            ‚Üí Parses your manifest.json
            ‚Üí Recognizes all declared entry points (background.js, content.tsx, index.html)
            ‚Üí Tells Vite to:
                ‚Üí Treat each as an individual build entry
                ‚Üí Bundle them correctly (e.g., esbuild for service workers, React for popups)
            ‚Üí Ensures permissions, resource scoping, and file outputs comply with Chrome Extension rules


========================================= Chrome Browser Storage =========================================
=> The most common browser storage types are:
    1. Cookies
    2. Local Storage (localStorage)
    3. Session Storage (sessionStorage)
    4. IndexedDB
    5. Cache Storage (used by Service Workers)

    üìöSummary Table
        +--------------+-------------+---------+-----------------+----------------+------------------------------+
        | Storage Type | Persistence | Capacity| Accessible to JS| Sent to Server |           Use Case           |
        +--------------+-------------+---------+-----------------+----------------+------------------------------+
        |   Cookies    | Configurable|   <4KB  |       Yes       |      Yes       | Auth, tracking, preferences  |
        | localStorage |  Persistent |  ~5MB   |       Yes       |      No        |    User data/settings        |
        |sessionStorage| Tab Session |  ~5MB   |       Yes       |      No        | Per-tab temporary data       |
        |  IndexedDB   |  Persistent | >200MB  |       Yes       |      No        | Large/complex structured data|
        |Cache Storage |  Persistent |  Large  |   Yes (via SW)  |      No        |  Assets, offline apps (PWAs) |
        +--------------+-------------+---------+-----------------+----------------+------------------------------+


=========================== Managing Environment-Based Logging in Vite + React ===========================
=> ‚úÖ Option 1: Use a custom logger utility that respects environment
        Create a logger.js (or utils/logger.js) and use that instead of console.log directly.

        üìù logger.js
        const isDev = import.meta.env.MODE === "development";

        export const log = (...args) => {
            if (isDev) console.log(...args);
        };

        export const warn = (...args) => {
            if (isDev) console.warn(...args);
        };

        export const error = (...args) => {
            console.error(...args); // Always show errors
        };

        ‚úÖ Pros: Clean, explicit, still keeps logs during development.
        ‚ùå Cons: You must replace all console.log with log().

=> ‚úÖ Option 2: Remove logs during build using Vite plugin
    Install this plugin:
        npm i -D vite-plugin-remove-console

    Then update your vite.config.js:
        import { defineConfig } from 'vite';
        import react from '@vitejs/plugin-react';
        import removeConsole from 'vite-plugin-remove-console';

        export default defineConfig(({ mode }) => ({
            plugins: [
                react(),
                ...(mode === 'production' ? [removeConsole()] : []),
            ],
        }));
        ‚úÖ Pros: No need to change any code, removes console.log, console.warn, etc., automatically during build.
        ‚úÖ Fully automatic.
        ‚ùå Cons: You can't keep any selective logs even in production (unless you whitelist some).


